@page
@model IndexModel
@{
    ViewData["Title"] = "Voice Live Chat";
}

<div class="container-fluid">
    <div class="row">
        <div class="col-md-8 mx-auto">
            <div class="text-center mb-4">
                <h1 class="display-4">Voice Live Chat</h1>
                <p class="lead">Chat with AI using text or voice input</p>
            </div>

            <!-- Session Info -->
            <div class="card mb-3">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <small class="text-muted">Session ID: <span id="sessionId">None</span></small>
                        </div>
                        <div>
                            <button type="button" class="btn btn-sm btn-outline-primary" id="newSessionBtn">New Session</button>
                            <a href="/Admin" class="btn btn-sm btn-outline-secondary">🔧 Admin</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Connection Status -->
            <div class="card mb-3">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <span class="badge bg-secondary" id="connectionStatus">Disconnected</span>
                            <span class="badge bg-secondary" id="voiceStatus">Voice Off</span>
                            <span class="badge bg-secondary" id="audioStatus">Audio Ready</span>
                        </div>
                        <div>
                            <button type="button" class="btn btn-primary" id="connectBtn" disabled>Connect</button>
                            <button type="button" class="btn btn-secondary" id="voiceToggleBtn" disabled>🎤 Start Voice</button>
                            <button type="button" class="btn btn-outline-info" id="downloadBtn" disabled>📥 Download History</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audio Level Indicator -->
            <div class="card mb-3" id="audioLevelCard" style="display: none;">
                <div class="card-body">
                    <div class="d-flex align-items-center">
                        <span class="me-2">🎤 Audio Level:</span>
                        <div class="progress flex-grow-1 me-2" style="height: 20px;">
                            <div class="progress-bar bg-success" id="audioLevel" role="progressbar" style="width: 0%"></div>
                        </div>
                        <span class="badge bg-info" id="audioLevelText">0%</span>
                    </div>
                </div>
            </div>

            <!-- Chat Messages -->
            <div class="card mb-3" style="height: 400px;">
                <div class="card-header">
                    <h5 class="card-title mb-0">Conversation</h5>
                </div>
                <div class="card-body" style="overflow-y: auto;" id="chatMessages">
                    <div class="text-muted text-center">
                        <p>Create a session and connect to start chatting...</p>
                    </div>
                </div>
            </div>

            <!-- Message Input -->
            <div class="card">
                <div class="card-body">
                    <div class="input-group">
                        <input type="text" class="form-control" id="messageInput" placeholder="Type your message..." disabled>
                        <button class="btn btn-primary" type="button" id="sendBtn" disabled>Send</button>
                    </div>
                </div>
            </div>

            <!-- Audio Player (hidden) -->
            <audio id="audioPlayer" controls style="display: none;"></audio>
        </div>
    </div>
</div>

<script>
    class VoiceLiveChat {
        constructor() {
            this.sessionId = null;
            this.isConnected = false;
            this.isRecording = false;
            this.eventSource = null;
            this.currentTextResponse = '';

            this.initializeElements();
            this.bindEvents();
            this.initializeAudio();
            this.checkStatus();
        }

        async initializeAudio() {
            try {
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 24000, // Voice Live API expects 24kHz
                        channelCount: 1,
                        // Additional constraints for better audio quality
                        googEchoCancellation: true,
                        googAutoGainControl: true,
                        googNoiseSuppression: true,
                        googHighpassFilter: true
                    }
                };

                // Request microphone access
                const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Create audio context for processing
                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000 // Match Voice Live API requirements
                });

                // Create analyser for audio level monitoring
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;

                // Connect media stream to analyser
                const source = audioContext.createMediaStreamSource(mediaStream);
                source.connect(analyser);

                this.audioContext = audioContext;
                this.analyser = analyser;
                this.mediaStream = mediaStream;

                this.updateAudioStatus('Audio Ready', 'bg-success');
                this.addMessage('system', 'Microphone access granted and audio system initialized');
            } catch (error) {
                console.error('Error initializing audio:', error);
                this.updateAudioStatus('Audio Error', 'bg-danger');
                this.addMessage('error', `Audio initialization failed: ${error.message}`);
            }
        }

        initializeElements() {
            this.newSessionBtn = document.getElementById('newSessionBtn');
            this.sessionIdDisplay = document.getElementById('sessionId');
            this.connectBtn = document.getElementById('connectBtn');
            this.voiceToggleBtn = document.getElementById('voiceToggleBtn');
            this.messageInput = document.getElementById('messageInput');
            this.sendBtn = document.getElementById('sendBtn');
            this.chatMessages = document.getElementById('chatMessages');
            this.connectionStatus = document.getElementById('connectionStatus');
            this.voiceStatus = document.getElementById('voiceStatus');
            this.audioStatus = document.getElementById('audioStatus');
            this.audioPlayer = document.getElementById('audioPlayer');
            this.downloadBtn = document.getElementById('downloadBtn');
            this.audioLevelCard = document.getElementById('audioLevelCard');
            this.audioLevel = document.getElementById('audioLevel');
            this.audioLevelText = document.getElementById('audioLevelText');
        }

        bindEvents() {
            this.newSessionBtn.addEventListener('click', () => this.createNewSession());
            this.connectBtn.addEventListener('click', () => this.toggleConnection());
            this.voiceToggleBtn.addEventListener('click', () => this.toggleVoice());
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            this.downloadBtn.addEventListener('click', () => this.downloadConversationHistory());
            this.messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.sendMessage();
            });
        }

        async createNewSession() {
            try {
                this.addMessage('system', 'Creating new session...');
                const response = await fetch('/api/chat/create-session', { method: 'POST' });
                const result = await response.json();

                if (response.ok) {
                    this.sessionId = result.sessionId;
                    this.sessionIdDisplay.textContent = this.sessionId;
                    this.addMessage('system', `Session created: ${this.sessionId}`);
                    this.updateUI(false, false); // Enable connect button
                } else {
                    this.addMessage('error', `Session creation failed: ${result.error}`);
                }
            } catch (error) {
                this.addMessage('error', `Session creation error: ${error.message}`);
            }
        }

        async checkStatus() {
            if (!this.sessionId) return;
            
            try {
                const response = await fetch(`/api/chat/status?sessionId=${this.sessionId}`);
                const status = await response.json();
                if (response.ok) {
                    this.updateUI(status.isConnected, status.isRecording);
                }
            } catch (error) {
                console.error('Error checking status:', error);
            }
        }

        async toggleConnection() {
            if (this.isConnected) {
                await this.disconnect();
            } else {
                await this.connect();
            }
        }

        async connect() {
            if (!this.sessionId) {
                this.addMessage('error', 'Please create a session first');
                return;
            }

            try {
                this.addMessage('system', 'Connecting to Voice Live API...');
                const response = await fetch('/api/chat/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId })
                });
                const result = await response.json();

                if (response.ok) {
                    this.isConnected = true;
                    this.updateUI(true, false);
                    this.addMessage('system', result.message);
                    this.startEventStream();
                    this.sendMessage('Hello');
                } else {
                    this.addMessage('error', `Connection failed: ${result.error}`);
                }
            } catch (error) {
                this.addMessage('error', `Connection error: ${error.message}`);
            }
        }

        async disconnect() {
            if (!this.sessionId) return;

            try {
                if (this.isRecording) {
                    await this.stopVoiceRecording();
                }

                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }

                const response = await fetch('/api/chat/disconnect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId })
                });
                const result = await response.json();

                this.isConnected = false;
                this.isRecording = false;
                this.updateUI(false, false);
                this.addMessage('system', result.message || 'Disconnected');
            } catch (error) {
                this.addMessage('error', `Disconnect error: ${error.message}`);
            }
        }

        async toggleVoice() {
            if (!this.isRecording) {
                await this.startVoiceRecording();
            } else {
                await this.stopVoiceRecording();
            }
        }

        async startVoiceRecording() {
            if (!this.sessionId) return;

            try {
                if (!this.audioContext || !this.mediaStream) {
                    throw new Error('Audio system not initialized');
                }

                // Resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                // Create audio processor for sending data to server
                await this.createAudioProcessor();

                // Show audio level indicator
                this.audioLevelCard.style.display = 'block';
                this.startAudioLevelMonitoring();

                // Start recording on server
                const response = await fetch('/api/chat/toggle-voice', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId })
                });
                const result = await response.json();

                if (response.ok && result.isRecording) {
                    this.isRecording = true;
                    this.updateUI(this.isConnected, true);
                    this.addMessage('system', result.message);
                } else {
                    throw new Error(result.error || 'Failed to start recording');
                }
            } catch (error) {
                this.addMessage('error', `Voice recording error: ${error.message}`);
                await this.stopVoiceRecording();
            }
        }

        async stopVoiceRecording() {
            if (!this.sessionId) return;

            try {
                // Stop audio processor
                if (this.audioProcessor) {
                    this.audioProcessor.disconnect();
                    this.audioProcessor = null;
                }

                // Hide audio level indicator
                this.audioLevelCard.style.display = 'none';
                this.stopAudioLevelMonitoring();

                // Stop recording on server
                const response = await fetch('/api/chat/toggle-voice', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId })
                });
                const result = await response.json();

                if (response.ok) {
                    this.isRecording = false;
                    this.updateUI(this.isConnected, false);
                    this.addMessage('system', result.message);
                } else {
                    this.addMessage('error', `Stop recording failed: ${result.error}`);
                }
            } catch (error) {
                this.addMessage('error', `Stop recording error: ${error.message}`);
            }
        }

        async createAudioProcessor() {
            try {
                // Create ScriptProcessorNode for audio processing
                this.audioProcessor = this.audioContext.createScriptProcessor(4096, 1, 1);
                
                const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                source.connect(this.audioProcessor);
                this.audioProcessor.connect(this.audioContext.destination);

                this.audioProcessor.onaudioprocess = async (event) => {
                    if (!this.isRecording) return;

                    const inputBuffer = event.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0);

                    // Convert float32 to PCM16
                    const pcm16Buffer = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        const sample = Math.max(-1, Math.min(1, inputData[i]));
                        pcm16Buffer[i] = sample * 0x7FFF;
                    }

                    // Convert to base64 for transmission
                    const uint8Array = new Uint8Array(pcm16Buffer.buffer);
                    const base64Audio = btoa(String.fromCharCode.apply(null, uint8Array));

                    // Send audio data to server
                    await this.sendAudioData(base64Audio);
                };
            } catch (error) {
                console.error('Error creating audio processor:', error);
                throw error;
            }
        }

        async sendAudioData(base64Audio) {
            if (!this.sessionId || !this.isConnected || !this.isRecording) return;

            try {
                await fetch('/api/chat/send-audio', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId, audioData: base64Audio })
                });
            } catch (error) {
                console.error('Error sending audio data:', error);
            }
        }

        startAudioLevelMonitoring() {
            if (!this.analyser) return;

            const bufferLength = this.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            this.audioLevelInterval = setInterval(() => {
                this.analyser.getByteFrequencyData(dataArray);
                
                // Calculate average audio level
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const percentage = Math.round((average / 255) * 100);

                // Update UI
                this.audioLevel.style.width = `${percentage}%`;
                this.audioLevelText.textContent = `${percentage}%`;

                // Change color based on level
                this.audioLevel.className = percentage > 50 ? 'progress-bar bg-warning' : 
                                          percentage > 20 ? 'progress-bar bg-info' : 
                                          'progress-bar bg-success';
            }, 100);
        }

        stopAudioLevelMonitoring() {
            if (this.audioLevelInterval) {
                clearInterval(this.audioLevelInterval);
                this.audioLevelInterval = null;
            }
        }

        updateAudioStatus(text, badgeClass) {
            this.audioStatus.textContent = text;
            this.audioStatus.className = `badge ${badgeClass}`;
        }

        async downloadConversationHistory() {
            if (!this.sessionId) return;

            try {
                const response = await fetch(`/api/chat/history?sessionId=${this.sessionId}`);
                const result = await response.json();

                if (response.ok && result.conversationHistory && result.conversationHistory.length > 0) {
                    // Create formatted content for download
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const content = this.formatHistoryForDownload(result.conversationHistory, timestamp);
                    
                    // Create and trigger download
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `conversation-history-${timestamp}.txt`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    this.addMessage('system', `Downloaded conversation history (${result.messageCount} messages)`);
                } else {
                    this.addMessage('system', 'No conversation history available to download');
                }
            } catch (error) {
                this.addMessage('error', `Download error: ${error.message}`);
            }
        }

        formatHistoryForDownload(history, timestamp) {
            const header = `Voice Live Chat Conversation History\nSession: ${this.sessionId}\nExported: ${new Date().toLocaleString()}\n${'='.repeat(50)}\n\n`;
            const messages = history.map((message, index) => `${index + 1}. ${message}`).join('\n');
            const footer = `\n\n${'='.repeat(50)}\nEnd of conversation (${history.length} messages)`;
            
            return header + messages + footer;
        }

        async sendMessage(messageOverride = null) {
            if (!this.sessionId) return;

            const message = messageOverride || this.messageInput.value.trim();
            if (!message || !this.isConnected) return;
            
            try {
                if (!messageOverride) {
                    this.addMessage('user', message);
                    this.messageInput.value = '';
                }
                
                const response = await fetch('/api/chat/send-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: this.sessionId, message: message })
                });
                
                const result = await response.json();
                if (!response.ok) {
                    this.addMessage('error', `Send failed: ${result.error}`);
                }
            } catch (error) {
                this.addMessage('error', `Send error: ${error.message}`);
            }
        }

        startEventStream() {
            if (!this.sessionId) return;

            this.eventSource = new EventSource(`/api/chat/stream?sessionId=${this.sessionId}`);

            this.eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleServerMessage(data);
                } catch (error) {
                    console.error('Error parsing server message:', error);
                }
            };

            this.eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                if (this.eventSource.readyState === EventSource.CLOSED) {
                    this.addMessage('system', 'Connection lost. Please reconnect.');
                    this.isConnected = false;
                    this.updateUI(false, false);
                }
            };
        }

        handleServerMessage(data) {
            switch (data.type) {
                case 'session_created':
                case 'session_updated':
                    this.addMessage('system', data.message);
                    break;

                case 'speech_started':
                    this.addMessage('system', '🎤 Speech detected in your audio');
                    break;

                case 'speech_stopped':
                    this.addMessage('system', '🔇 Speech ended, processing...');
                    break;

                case 'audio_committed':
                    this.addMessage('system', '✅ Audio processed and committed');
                    break;

                case 'user_speech_transcribed':
                    // Display the recognized speech text
                    this.addMessage('user', `🗣️ "${data.text}"`);
                    this.addMessage('system', '✅ Speech recognized and transcribed');
                    break;

                case 'response_started':
                    this.currentTextResponse = '';
                    this.addMessage('assistant', '🤖 Generating response...');
                    break;

                case 'text_delta':
                    this.updateLastAssistantMessage(data.text);
                    break;

                case 'audio_response':
                    if (data.audioData) {
                        this.playAudio(data.audioData);
                    }
                    break;

                case 'response_completed':
                    this.addMessage('system', 'Response completed');
                    break;

                case 'error':
                    this.addMessage('error', `Error: ${data.error}`);
                    break;
            }
        }

        updateLastAssistantMessage(textDelta) {
            this.currentTextResponse += textDelta;
            const messages = this.chatMessages.children;
            const lastMessage = messages[messages.length - 1];

            if (lastMessage && lastMessage.classList.contains('assistant-message')) {
                const content = lastMessage.querySelector('.message-content');
                if (content) {
                    content.textContent = this.currentTextResponse;
                }
            } else {
                this.addMessage('assistant', this.currentTextResponse);
            }
        }

        playAudio(base64Audio) {
            try {
                const audioBlob = this.base64ToBlob(base64Audio, 'audio/wav');
                const audioUrl = URL.createObjectURL(audioBlob);
                this.audioPlayer.src = audioUrl;
                this.audioPlayer.play();

                // Cleanup URL after playing
                this.audioPlayer.addEventListener('ended', () => {
                    URL.revokeObjectURL(audioUrl);
                }, { once: true });
            } catch (error) {
                console.error('Error playing audio:', error);
            }
        }

        base64ToBlob(base64, contentType) {
            const sliceSize = 1024;
            const byteCharacters = atob(base64);
            const bytesLength = byteCharacters.length;
            const slicesCount = Math.ceil(bytesLength / sliceSize);
            const byteArrays = new Array(slicesCount);

            for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
                const begin = sliceIndex * sliceSize;
                const end = Math.min(begin + sliceSize, bytesLength);
                const bytes = new Array(end - begin);
                for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
                    bytes[i] = byteCharacters[offset].charCodeAt(0);
                }
                byteArrays[sliceIndex] = new Uint8Array(bytes);
            }
            return new Blob(byteArrays, { type: contentType });
        }

        addMessage(type, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-3 ${type}-message`;

            let badgeClass = 'bg-secondary';
            let icon = '';

            switch (type) {
                case 'user':
                    badgeClass = 'bg-primary';
                    icon = '👤';
                    break;
                case 'assistant':
                    badgeClass = 'bg-success';
                    icon = '🤖';
                    break;
                case 'system':
                    badgeClass = 'bg-info';
                    icon = 'ℹ️';
                    break;
                case 'error':
                    badgeClass = 'bg-danger';
                    icon = '⚠️';
                    break;
            }

            messageDiv.innerHTML = `
                <div class="d-flex align-items-start">
                    <span class="badge ${badgeClass} me-2">${icon} ${type.charAt(0).toUpperCase() + type.slice(1)}</span>
                    <div class="message-content flex-grow-1">${content}</div>
                </div>
            `;

            this.chatMessages.appendChild(messageDiv);
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
        }

        updateUI(connected, recording) {
            this.isConnected = connected;
            this.isRecording = recording;

            // Update connection status
            this.connectionStatus.textContent = connected ? 'Connected' : 'Disconnected';
            this.connectionStatus.className = `badge ${connected ? 'bg-success' : 'bg-secondary'}`;

            // Update voice status
            this.voiceStatus.textContent = recording ? 'Recording' : 'Voice Off';
            this.voiceStatus.className = `badge ${recording ? 'bg-warning' : 'bg-secondary'}`;

            // Update buttons
            this.connectBtn.textContent = connected ? 'Disconnect' : 'Connect';
            this.connectBtn.className = `btn ${connected ? 'btn-danger' : 'btn-primary'}`;
            this.connectBtn.disabled = !this.sessionId;

            this.voiceToggleBtn.textContent = recording ? '🔇 Stop Voice' : '🎤 Start Voice';
            this.voiceToggleBtn.disabled = !connected;

            // Update download button - only enabled when disconnected
            this.downloadBtn.disabled = connected || !this.sessionId;

            // Update input
            this.messageInput.disabled = !connected;
            this.sendBtn.disabled = !connected;
        }
    }

    // Initialize the chat when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        new VoiceLiveChat();
    });
</script>
